@using CheapShotcutRandomizer.Models

<MudPaper Class="pa-4 mb-2">
    <MudGrid>
        <MudItem xs="12">
            <MudStack Row="true" AlignItems="AlignItems.Center">
                <MudIcon Icon="@GetStatusIcon()" Color="@GetStatusColor()" />
                <MudText Typo="Typo.h6">@Path.GetFileName(Job.SourceVideoPath)</MudText>
                <MudSpacer />
                <MudChip T="string" Size="Size.Small" Color="@GetStatusColor()">
                    @Job.Status.ToString()
                </MudChip>
            </MudStack>
        </MudItem>

        <MudItem xs="12">
            <MudText Typo="Typo.body2">
                Output: @Job.OutputPath
            </MudText>
        </MudItem>

        @* File size information *@
        @if (Job.Status == RenderJobStatus.Completed && Job.OutputFileSizeBytes.HasValue)
        {
            <MudItem xs="12">
                <MudStack Row="true" Spacing="2">
                    <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Filled.Storage" Variant="Variant.Text">
                        Output: @Job.GetOutputFileSizeFormatted()
                    </MudChip>

                    @if (Job.IsTwoStageRender && Job.IntermediateFileSizeBytes.HasValue)
                    {
                        <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Filled.Schedule" Variant="Variant.Text" Color="Color.Info">
                            Temp: @Job.GetIntermediateFileSizeFormatted()
                        </MudChip>
                        <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Filled.Summarize" Variant="Variant.Text" Color="Color.Warning">
                            Total: @FormatTotalSize()
                        </MudChip>
                    }
                </MudStack>
            </MudItem>
        }

        @if (Job.Status == RenderJobStatus.Running)
        {
            <MudItem xs="12">
                <MudProgressLinear Value="@Job.ProgressPercentage"
                                   Color="Color.Primary"
                                   Size="Size.Large">
                    <MudText Typo="Typo.body2">
                        @Job.ProgressPercentage.ToString("F1")%
                        (@GetProgressTimecode())
                    </MudText>
                </MudProgressLinear>
            </MudItem>

            @if (Job.EstimatedTimeRemaining.HasValue)
            {
                <MudItem xs="12">
                    <MudText Typo="Typo.caption">
                        ETA: @Job.EstimatedTimeRemaining.Value.ToString(@"hh\:mm\:ss")
                    </MudText>
                </MudItem>
            }
        }

        @if (Job.Status == RenderJobStatus.Pending)
        {
            <MudItem xs="12">
                <MudText Typo="Typo.body2" Color="Color.Info">
                    Queued - Waiting to start...
                </MudText>
            </MudItem>
        }

        <MudItem xs="12">
            <MudStack Row="true" Spacing="2">
                @if (Job.Status == RenderJobStatus.Running)
                {
                    <MudButton Size="Size.Small" Variant="Variant.Filled"
                               Color="Color.Warning" OnClick="@(() => OnPause.InvokeAsync(Job.JobId))">
                        Pause
                    </MudButton>
                    <MudButton Size="Size.Small" Variant="Variant.Filled"
                               Color="Color.Error" OnClick="@(() => OnCancel.InvokeAsync(Job.JobId))">
                        Cancel
                    </MudButton>
                }
                else if (Job.Status == RenderJobStatus.Paused)
                {
                    <MudButton Size="Size.Small" Variant="Variant.Filled"
                               Color="Color.Success" OnClick="@(() => OnResume.InvokeAsync(Job.JobId))">
                        Resume
                    </MudButton>
                    <MudButton Size="Size.Small" Variant="Variant.Filled"
                               Color="Color.Error" OnClick="@(() => OnCancel.InvokeAsync(Job.JobId))">
                        Cancel
                    </MudButton>
                }
                else if (Job.Status == RenderJobStatus.Failed || Job.Status == RenderJobStatus.DeadLetter)
                {
                    <MudButton Size="Size.Small" Variant="Variant.Outlined"
                               Color="Color.Primary" OnClick="@(() => OnRetry.InvokeAsync(Job.JobId))">
                        Retry
                    </MudButton>
                    <MudButton Size="Size.Small" Variant="Variant.Outlined"
                               Color="Color.Error" OnClick="@ShowErrorDetails">
                        View Error
                    </MudButton>
                    <MudButton Size="Size.Small" Variant="Variant.Outlined"
                               Color="Color.Error" OnClick="@(() => OnDelete.InvokeAsync(Job.JobId))"
                               StartIcon="@Icons.Material.Filled.Delete">
                        Delete
                    </MudButton>
                }
                else if (Job.Status == RenderJobStatus.Completed)
                {
                    <MudButton Size="Size.Small" Variant="Variant.Outlined"
                               Color="Color.Success" OnClick="@OpenOutputFolder">
                        Open Folder
                    </MudButton>
                    <MudButton Size="Size.Small" Variant="Variant.Outlined"
                               Color="Color.Error" OnClick="@(() => OnDelete.InvokeAsync(Job.JobId))"
                               StartIcon="@Icons.Material.Filled.Delete">
                        Delete
                    </MudButton>
                }
                else if (Job.Status == RenderJobStatus.Pending)
                {
                    <MudButton Size="Size.Small" Variant="Variant.Outlined"
                               Color="Color.Error" OnClick="@(() => OnDelete.InvokeAsync(Job.JobId))"
                               StartIcon="@Icons.Material.Filled.Delete">
                        Delete
                    </MudButton>
                }
                else if (Job.Status == RenderJobStatus.Cancelled)
                {
                    <MudButton Size="Size.Small" Variant="Variant.Outlined"
                               Color="Color.Error" OnClick="@(() => OnDelete.InvokeAsync(Job.JobId))"
                               StartIcon="@Icons.Material.Filled.Delete">
                        Delete
                    </MudButton>
                }
            </MudStack>
        </MudItem>

        @if (!string.IsNullOrEmpty(Job.LastError) && _showError)
        {
            <MudItem xs="12">
                <MudAlert Severity="Severity.Error" Dense="true" CloseIcon="true" CloseIconClicked="@(() => _showError = false)">
                    @Job.LastError
                </MudAlert>
            </MudItem>
        }
    </MudGrid>
</MudPaper>

@code {
    [Parameter]
    public RenderJob Job { get; set; } = null!;

    [Parameter]
    public EventCallback<Guid> OnPause { get; set; }

    [Parameter]
    public EventCallback<Guid> OnResume { get; set; }

    [Parameter]
    public EventCallback<Guid> OnCancel { get; set; }

    [Parameter]
    public EventCallback<Guid> OnRetry { get; set; }

    [Parameter]
    public EventCallback<Guid> OnDelete { get; set; }

    private bool _showError = false;

    private string GetProgressTimecode()
    {
        if (Job.TotalFrames.HasValue && Job.TotalFrames.Value > 0)
        {
            var currentTime = Job.FramesToTimecode(Job.CurrentFrame);
            var totalTime = Job.FramesToTimecode(Job.TotalFrames.Value);
            return $"{currentTime} / {totalTime}";
        }

        // Fallback to frame display if total frames not available
        return $"Frame {Job.CurrentFrame}";
    }

    private string GetStatusIcon() => Job.Status switch
    {
        RenderJobStatus.Pending => Icons.Material.Filled.HourglassEmpty,
        RenderJobStatus.Running => Icons.Material.Filled.PlayArrow,
        RenderJobStatus.Paused => Icons.Material.Filled.Pause,
        RenderJobStatus.Completed => Icons.Material.Filled.CheckCircle,
        RenderJobStatus.Failed => Icons.Material.Filled.Error,
        RenderJobStatus.Cancelled => Icons.Material.Filled.Cancel,
        RenderJobStatus.DeadLetter => Icons.Material.Filled.Delete,
        _ => Icons.Material.Filled.Help
    };

    private Color GetStatusColor() => Job.Status switch
    {
        RenderJobStatus.Running => Color.Primary,
        RenderJobStatus.Completed => Color.Success,
        RenderJobStatus.Failed => Color.Error,
        RenderJobStatus.Cancelled => Color.Warning,
        RenderJobStatus.DeadLetter => Color.Error,
        _ => Color.Default
    };

    private void ShowErrorDetails()
    {
        _showError = !_showError;
    }

    private void OpenOutputFolder()
    {
        try
        {
            var directory = Path.GetDirectoryName(Job.OutputPath);
            if (!string.IsNullOrEmpty(directory) && Directory.Exists(directory))
            {
                System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo
                {
                    FileName = directory,
                    UseShellExecute = true
                });
            }
        }
        catch
        {
            // Silently fail if can't open folder
        }
    }

    private string FormatTotalSize()
    {
        if (!Job.OutputFileSizeBytes.HasValue || !Job.IntermediateFileSizeBytes.HasValue)
            return "N/A";

        var totalBytes = Job.OutputFileSizeBytes.Value + Job.IntermediateFileSizeBytes.Value;

        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        double len = totalBytes;
        int order = 0;

        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len /= 1024;
        }

        return $"{len:F2} {sizes[order]}";
    }
}
