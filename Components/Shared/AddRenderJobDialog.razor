@using CheapShotcutRandomizer.Models
@using CheapShotcutRandomizer.Services
@using CheapAvaloniaBlazor.Services
@inject IDesktopInteropService DesktopInterop
@inject HardwareDetectionService HardwareService
@inject ShotcutService ShotcutService
@inject SettingsService SettingsService

<MudDialog Visible="@IsVisible"
           VisibleChanged="@OnDialogVisibleChanged"
           Options="@_dialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h5">Add Render Job</MudText>
    </TitleContent>
    <DialogContent>
        <MudStack Spacing="3">

            <MudStack Row="true" Spacing="2">
                <MudTextField @bind-Value="_sourcePath"
                              Label="Source File"
                              Variant="Variant.Outlined"
                              FullWidth="true"
                              ReadOnly="true" />
                <MudButton Variant="Variant.Filled"
                           Color="Color.Primary"
                           OnClick="@BrowseSource">
                    Browse...
                </MudButton>
            </MudStack>

            <MudStack Row="true" Spacing="2">
                <MudTextField @bind-Value="_outputPath"
                              Label="Output Path"
                              Variant="Variant.Outlined"
                              FullWidth="true"
                              ReadOnly="true" />
                <MudButton Variant="Variant.Filled"
                           Color="Color.Primary"
                           OnClick="@BrowseOutput">
                    Browse...
                </MudButton>
            </MudStack>

            <MudSelect Value="_renderType"
                       ValueChanged="@OnRenderTypeChanged"
                       Label="Render Type"
                       Variant="Variant.Outlined"
                       T="RenderType">
                <MudSelectItem Value="RenderType.MltProject" T="RenderType">MLT Project</MudSelectItem>
                <MudSelectItem Value="RenderType.RifeInterpolation" T="RenderType">RIFE Interpolation</MudSelectItem>
            </MudSelect>

            @* MLT Encoding Settings - Show ONLY for MLT Project *@
            @if (_renderType == RenderType.MltProject)
            {
                <MudDivider />
                <MudText Typo="Typo.subtitle2">MLT Settings</MudText>

                <MudSlider @bind-Value="_mltThreads"
                           Min="1"
                           Max="@_maxThreads"
                           Step="1"
                           Color="Color.Primary"
                           Style="width: 100%;">
                    CPU Threads: @_mltThreads
                </MudSlider>

                <MudSelect @bind-Value="_mltPreset"
                           Label="Quality Preset"
                           Variant="Variant.Outlined"
                           T="string">
                    <MudSelectItem Value="@("ultrafast")" T="string">Ultra Fast</MudSelectItem>
                    <MudSelectItem Value="@("superfast")" T="string">Super Fast</MudSelectItem>
                    <MudSelectItem Value="@("veryfast")" T="string">Very Fast</MudSelectItem>
                    <MudSelectItem Value="@("faster")" T="string">Faster</MudSelectItem>
                    <MudSelectItem Value="@("fast")" T="string">Fast</MudSelectItem>
                    <MudSelectItem Value="@("medium")" T="string">Medium (Recommended)</MudSelectItem>
                    <MudSelectItem Value="@("slow")" T="string">Slow</MudSelectItem>
                    <MudSelectItem Value="@("slower")" T="string">Slower</MudSelectItem>
                </MudSelect>

                <MudSlider @bind-Value="_mltCrf"
                           Min="15"
                           Max="28"
                           Step="1"
                           Color="Color.Primary"
                           Style="width: 100%;">
                    Quality (CRF): @_mltCrf (Lower = Better)
                </MudSlider>
            }

            @* RIFE Settings - Show ONLY for RIFE Interpolation *@
            @if (_renderType == RenderType.RifeInterpolation)
            {
                <MudDivider />
                <MudText Typo="Typo.subtitle2">RIFE Interpolation Settings</MudText>

                <MudSlider @bind-Value="_rifeMultiplier"
                           Min="2"
                           Max="8"
                           Step="1"
                           Color="Color.Primary"
                           Style="width: 100%;">
                    Interpolation Multiplier: @_rifeMultiplier x
                </MudSlider>

                <MudNumericField @bind-Value="_rifeTargetFps"
                                 Label="Target FPS"
                                 Variant="Variant.Outlined"
                                 Min="30"
                                 Max="240"
                                 T="int" />

                <MudSelect @bind-Value="_rifeQuality"
                           Label="Quality Preset"
                           Variant="Variant.Outlined"
                           T="string">
                    <MudSelectItem Value="@("draft")" T="string">Draft (Fastest)</MudSelectItem>
                    <MudSelectItem Value="@("medium")" T="string">Medium (Recommended)</MudSelectItem>
                    <MudSelectItem Value="@("high")" T="string">High Quality</MudSelectItem>
                </MudSelect>
            }

            @* Track Selection - Show for MLT Project OR RIFE with MLT source, but only if ShowTrackSelection is true *@
            @if (ShowTrackSelection && (_renderType == RenderType.MltProject || (_renderType == RenderType.RifeInterpolation && _loadedMltProject != null)) && _tracks.Any())
            {
                <MudDivider />
                <MudText Typo="Typo.subtitle2">Track Selection</MudText>

                @if (_videoTracks.Any())
                {
                    <MudText Typo="Typo.body2" Color="Color.Primary">Video Tracks</MudText>
                    <MudStack Row="true" Spacing="2">
                        @foreach (var track in _videoTracks)
                        {
                            <MudCheckBox @bind-Value="track.Selected"
                                         Label="@track.DisplayName"
                                         Color="Color.Primary"
                                         T="bool" />
                        }
                    </MudStack>
                }

                @if (_audioTracks.Any())
                {
                    <MudText Typo="Typo.body2" Color="Color.Secondary">Audio Tracks</MudText>
                    <MudStack Row="true" Spacing="2">
                        @foreach (var track in _audioTracks)
                        {
                            <MudCheckBox @bind-Value="track.Selected"
                                         Label="@track.DisplayName"
                                         Color="Color.Secondary"
                                         T="bool" />
                        }
                    </MudStack>
                }
            }

            @* Render Range - Show for MLT Project OR RIFE with MLT source, but only if ShowRenderRange is true *@
            @if (ShowRenderRange && (_renderType == RenderType.MltProject || (_renderType == RenderType.RifeInterpolation && _loadedMltProject != null)) && !string.IsNullOrEmpty(_renderRangeDescription))
            {
                <MudDivider />
                <MudText Typo="Typo.subtitle2">Render Range</MudText>

                @if (!_useCustomRange)
                {
                    <MudAlert Severity="Severity.Info" Icon="@Icons.Material.Filled.ContentCut">
                        @_renderRangeDescription
                    </MudAlert>
                }

                <MudCheckBox @bind-Value="_useCustomRange" T="bool" Label="Override Markers (Custom Range)" Color="Color.Primary" />

                @if (_useCustomRange)
                {
                    @if (!string.IsNullOrEmpty(_maxEndTimeDisplay))
                    {
                        <MudAlert Severity="Severity.Normal" Dense="true">
                            Maximum end time: @_maxEndTimeDisplay
                        </MudAlert>
                    }

                    <MudStack Row="true" Spacing="2">
                        <MudTextField @bind-Value="_inPointTimecode"
                                      Label="Start Time (HH:MM:SS.mmm)"
                                      Variant="Variant.Outlined"
                                      Placeholder="00:00:00.000"
                                      HelperText="Format: HH:MM:SS or HH:MM:SS.mmm"
                                      Error="@_inPointError"
                                      ErrorText="@_inPointErrorText" />
                        <MudTextField @bind-Value="_outPointTimecode"
                                      Label="End Time (HH:MM:SS.mmm)"
                                      Variant="Variant.Outlined"
                                      Placeholder="00:10:30.000"
                                      HelperText="Format: HH:MM:SS or HH:MM:SS.mmm"
                                      Error="@_outPointError"
                                      ErrorText="@_outPointErrorText" />
                    </MudStack>
                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                        Leave empty to render from start or to end
                    </MudText>
                }
            }

            @if (!string.IsNullOrEmpty(_estimatedTime))
            {
                <MudAlert Severity="Severity.Info">
                    @_estimatedTime
                </MudAlert>
            }

            @if (!string.IsNullOrEmpty(_validationError))
            {
                <MudAlert Severity="Severity.Error">
                    @_validationError
                </MudAlert>
            }
        </MudStack>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="@Cancel" Variant="Variant.Text">Cancel</MudButton>
        <MudButton Color="Color.Primary"
                   Variant="Variant.Filled"
                   OnClick="@AddJob"
                   Disabled="@(!IsValid())">
            Add to Queue
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [Parameter]
    public bool IsVisible { get; set; }

    [Parameter]
    public EventCallback<bool> IsVisibleChanged { get; set; }

    [Parameter]
    public EventCallback<RenderJob> OnJobAdded { get; set; }

    [Parameter]
    public string? PrePopulatedSourcePath { get; set; }

    [Parameter]
    public bool ShowTrackSelection { get; set; } = true;

    [Parameter]
    public bool ShowRenderRange { get; set; } = true;

    private string _sourcePath = string.Empty;
    private string _outputPath = string.Empty;
    private RenderType _renderType = RenderType.MltProject;

    // MLT settings
    private int _mltThreads = Environment.ProcessorCount;
    private int _maxThreads = Environment.ProcessorCount;
    private string _mltPreset = "medium";
    private int _mltCrf = 23;

    // RIFE settings
    private int _rifeMultiplier = 2;
    private int _rifeTargetFps = 60;
    private string _rifeQuality = "medium";

    private string _estimatedTime = string.Empty;
    private string _validationError = string.Empty;
    private HardwareCapabilities? _hardware;
    private AppSettings? _appSettings;

    // Track selection
    private List<SelectableTrack> _tracks = [];
    private List<SelectableTrack> _videoTracks = [];
    private List<SelectableTrack> _audioTracks = [];

    // Marker/range settings
    private Mlt? _loadedMltProject;
    private string _renderRangeDescription = string.Empty;
    private bool _useCustomRange = false;
    private int? _customInPoint;
    private int? _customOutPoint;
    private string _inPointTimecode = string.Empty;
    private string _outPointTimecode = string.Empty;
    private bool _inPointError = false;
    private string _inPointErrorText = string.Empty;
    private bool _outPointError = false;
    private string _outPointErrorText = string.Empty;
    private string _maxEndTimeDisplay = string.Empty;

    private DialogOptions _dialogOptions = new()
    {
        MaxWidth = MaxWidth.Medium,
        FullWidth = true,
        CloseButton = true,
        BackdropClick = false,
        Position = DialogPosition.Center
    };

    private class SelectableTrack
    {
        public TrackInfo Info { get; set; } = null!;
        public bool Selected { get; set; } = true;
        public string DisplayName => $"{Info.Name} ({Info.Type.ToUpper()[0]}{Info.Index})";
    }

    protected override async Task OnInitializedAsync()
    {
        _hardware = await HardwareService.DetectHardwareAsync();
        _maxThreads = _hardware.CpuCoreCount;
        _mltThreads = _hardware.CpuCoreCount;

        // Load app settings for defaults
        _appSettings = await SettingsService.LoadSettingsAsync();
        _mltCrf = _appSettings.DefaultCrf;
        _mltPreset = _appSettings.DefaultPreset;

        // Set default output folder to user's Videos directory
        var videosFolder = Environment.GetFolderPath(Environment.SpecialFolder.MyVideos);
        _outputPath = Path.Combine(videosFolder, "output.mp4");
    }

    protected override async Task OnParametersSetAsync()
    {
        // If a source path is pre-populated and different from current, load it automatically
        if (!string.IsNullOrEmpty(PrePopulatedSourcePath) && _sourcePath != PrePopulatedSourcePath)
        {
            _sourcePath = PrePopulatedSourcePath;

            // Auto-populate output path
            var videosFolder = Environment.GetFolderPath(Environment.SpecialFolder.MyVideos);
            var fileNameWithoutExt = Path.GetFileNameWithoutExtension(_sourcePath);
            var suffix = _renderType == RenderType.RifeInterpolation ? "_rife" : "_rendered";
            _outputPath = Path.Combine(videosFolder, $"{fileNameWithoutExt}{suffix}.mp4");

            // Load tracks and markers if this is an MLT file (for both MLT and RIFE render types)
            if (File.Exists(_sourcePath) && _sourcePath.EndsWith(".mlt", StringComparison.OrdinalIgnoreCase))
            {
                await LoadMltProjectDataAsync(_sourcePath);
            }

            UpdateEstimatedTime();
        }

        await base.OnParametersSetAsync();
    }

    private async Task BrowseSource()
    {
        // For RIFE: allow both MLT and video files
        // For MLT Project: only MLT files
        var filters = _renderType == RenderType.MltProject
            ? new List<CheapAvaloniaBlazor.Models.FileFilter>
            {
                new() { Name = "MLT Files", Extensions = new[] { "*.mlt" } },
                new() { Name = "All Files", Extensions = new[] { "*.*" } }
            }
            : new List<CheapAvaloniaBlazor.Models.FileFilter>
            {
                new() { Name = "Video Files", Extensions = new[] { "*.mp4", "*.mkv", "*.avi" } },
                new() { Name = "MLT Project Files", Extensions = new[] { "*.mlt" } },
                new() { Name = "All Files", Extensions = new[] { "*.*" } }
            };

        var options = new CheapAvaloniaBlazor.Models.FileDialogOptions
        {
            Title = "Select Source File",
            Filters = filters
        };

        var selectedFile = await DesktopInterop.OpenFileDialogAsync(options);

        if (!string.IsNullOrEmpty(selectedFile))
        {
            _sourcePath = selectedFile;

            // Auto-populate output path to Videos folder with source filename
            var videosFolder = Environment.GetFolderPath(Environment.SpecialFolder.MyVideos);
            var fileNameWithoutExt = Path.GetFileNameWithoutExtension(_sourcePath);
            var suffix = _renderType == RenderType.RifeInterpolation ? "_rife" : "_rendered";
            _outputPath = Path.Combine(videosFolder, $"{fileNameWithoutExt}{suffix}.mp4");

            // Load tracks and markers if this is an MLT file (for both MLT and RIFE render types)
            if (_sourcePath.EndsWith(".mlt", StringComparison.OrdinalIgnoreCase))
            {
                await LoadMltProjectDataAsync(_sourcePath);
            }

            UpdateEstimatedTime();
        }
    }

    private async Task BrowseOutput()
    {
        var defaultFileName = !string.IsNullOrEmpty(_sourcePath)
            ? Path.GetFileNameWithoutExtension(_sourcePath) + ".mp4"
            : "output.mp4";

        var filters = new List<CheapAvaloniaBlazor.Models.FileFilter>
        {
            new() { Name = "MP4 Files", Extensions = new[] { "*.mp4" } },
            new() { Name = "MKV Files", Extensions = new[] { "*.mkv" } },
            new() { Name = "All Files", Extensions = new[] { "*.*" } }
        };

        var options = new CheapAvaloniaBlazor.Models.FileDialogOptions
        {
            Title = "Save Output As",
            DefaultFileName = defaultFileName,
            Filters = filters
        };

        var selectedFile = await DesktopInterop.SaveFileDialogAsync(options);

        if (!string.IsNullOrEmpty(selectedFile))
        {
            _outputPath = selectedFile;
        }
    }

    private async Task LoadMltProjectDataAsync(string mltPath)
    {
        try
        {
            var project = await ShotcutService.LoadProjectAsync(mltPath);
            if (project != null)
            {
                _loadedMltProject = project;

                // Load tracks
                var trackInfos = ShotcutService.GetTracks(project);
                _tracks = trackInfos.Select(t => new SelectableTrack
                {
                    Info = t,
                    Selected = !t.IsHidden // Select by default if not hidden
                }).ToList();

                _videoTracks = _tracks.Where(t => t.Info.Type == "video").ToList();
                _audioTracks = _tracks.Where(t => t.Info.Type == "audio").ToList();

                // Load markers
                _loadedMltProject.ParseMarkers();
                _renderRangeDescription = _loadedMltProject.GetRenderRangeDescription();

                // Calculate and display max end time
                var maxEndTime = _loadedMltProject.GetTotalDurationTimecode();
                if (!string.IsNullOrEmpty(maxEndTime))
                    _maxEndTimeDisplay = maxEndTime;

                // Initialize custom range with project markers
                _customInPoint = _loadedMltProject.InMarker;
                _customOutPoint = _loadedMltProject.OutMarker;

                // Initialize timecode fields
                if (_loadedMltProject.InMarker.HasValue)
                    _inPointTimecode = _loadedMltProject.FramesToTimecode(_loadedMltProject.InMarker.Value);

                if (_loadedMltProject.OutMarker.HasValue)
                    _outPointTimecode = _loadedMltProject.FramesToTimecode(_loadedMltProject.OutMarker.Value);
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Error loading MLT project data: {ex.Message}");
            _tracks = [];
            _videoTracks = [];
            _audioTracks = [];
            _renderRangeDescription = string.Empty;
            _maxEndTimeDisplay = string.Empty;
        }
    }

    private void UpdateEstimatedTime()
    {
        if (_hardware == null || string.IsNullOrEmpty(_sourcePath))
        {
            _estimatedTime = string.Empty;
            return;
        }

        // Estimate based on typical video duration (placeholder - would need actual video info)
        var estimatedDuration = TimeSpan.FromMinutes(10); // Default estimate

        if (_renderType == RenderType.MltProject)
        {
            // MLT can use NVENC or CPU based on codec setting
            var useNvenc = _appSettings?.DefaultCodec?.Contains("nvenc") ?? false;
            var renderTime = _hardware.EstimateFFmpegRenderTime(estimatedDuration, useNvenc);
            var method = useNvenc ? "NVENC" : "CPU";
            _estimatedTime = $"Estimated render time: ~{renderTime.TotalMinutes:F0} minutes ({method})";

            if (useNvenc && _hardware.NvencAvailable)
            {
                var cpuTime = _hardware.EstimateFFmpegRenderTime(estimatedDuration, useNvenc: false);
                _estimatedTime += $" - Saves ~{(cpuTime - renderTime).TotalMinutes:F0} minutes vs CPU!";
            }
        }
        else
        {
            // RIFE workflow - just show a simple estimate, no NVENC bragging
            var renderTime = _hardware.EstimateFFmpegRenderTime(estimatedDuration, _hardware.NvencAvailable);
            _estimatedTime = $"Estimated render time: ~{renderTime.TotalMinutes:F0} minutes";
        }
    }

    private void ValidateAndConvertTimecodes()
    {
        // Reset errors
        _inPointError = false;
        _inPointErrorText = string.Empty;
        _outPointError = false;
        _outPointErrorText = string.Empty;

        if (_loadedMltProject == null || !_useCustomRange)
            return;

        // Validate and convert in point
        if (!string.IsNullOrWhiteSpace(_inPointTimecode))
        {
            try
            {
                _customInPoint = _loadedMltProject.TimecodeToFrames(_inPointTimecode);
            }
            catch (Exception ex)
            {
                _inPointError = true;
                _inPointErrorText = $"Invalid timecode format: {ex.Message}";
                _customInPoint = null;
            }
        }
        else
        {
            _customInPoint = null;
        }

        // Validate and convert out point
        if (!string.IsNullOrWhiteSpace(_outPointTimecode))
        {
            try
            {
                _customOutPoint = _loadedMltProject.TimecodeToFrames(_outPointTimecode);
            }
            catch (Exception ex)
            {
                _outPointError = true;
                _outPointErrorText = $"Invalid timecode format: {ex.Message}";
                _customOutPoint = null;
            }
        }
        else
        {
            _customOutPoint = null;
        }
    }

    private bool IsValid()
    {
        _validationError = string.Empty;

        if (string.IsNullOrEmpty(_sourcePath))
        {
            _validationError = "Please select a source file";
            return false;
        }

        // Don't check File.Exists here - it will be checked when actually adding the job
        // This prevents validation errors while the file is being written

        if (string.IsNullOrEmpty(_outputPath))
        {
            _validationError = "Please specify an output path";
            return false;
        }

        if (_renderType == RenderType.MltProject && !_sourcePath.EndsWith(".mlt", StringComparison.OrdinalIgnoreCase))
        {
            _validationError = "Source file must be an MLT project (.mlt)";
            return false;
        }

        // For RIFE, accept both video files and MLT files (MLT will be rendered first)
        if (_renderType == RenderType.RifeInterpolation)
        {
            var isMlt = _sourcePath.EndsWith(".mlt", StringComparison.OrdinalIgnoreCase);
            var isVideo = _sourcePath.EndsWith(".mp4", StringComparison.OrdinalIgnoreCase) ||
                          _sourcePath.EndsWith(".mkv", StringComparison.OrdinalIgnoreCase) ||
                          _sourcePath.EndsWith(".avi", StringComparison.OrdinalIgnoreCase);

            if (!isMlt && !isVideo)
            {
                _validationError = "Source file must be a video file (.mp4, .mkv, .avi) or MLT project (.mlt)";
                return false;
            }
        }

        // Validate timecodes if custom range is enabled (only for MLT files)
        var isSourceMlt = _sourcePath.EndsWith(".mlt", StringComparison.OrdinalIgnoreCase);
        if (_useCustomRange && isSourceMlt)
        {
            ValidateAndConvertTimecodes();

            if (_inPointError || _outPointError)
            {
                _validationError = "Please fix timecode format errors";
                return false;
            }
        }

        return true;
    }

    private async Task AddJob()
    {
        if (!IsValid())
            return;

        // Verify source file actually exists before proceeding
        if (!File.Exists(_sourcePath))
        {
            _validationError = "Source file does not exist";
            StateHasChanged();
            return;
        }

        var isSourceMlt = _sourcePath.EndsWith(".mlt", StringComparison.OrdinalIgnoreCase);
        var isTwoStage = _renderType == RenderType.RifeInterpolation && isSourceMlt;

        var renderJob = new RenderJob
        {
            SourceVideoPath = _sourcePath,
            OutputPath = _outputPath,
            RenderType = _renderType,
            Status = RenderJobStatus.Pending,
            IsTwoStageRender = isTwoStage
        };

        // Set up two-stage rendering path if needed (MLT → temp → RIFE)
        if (isTwoStage)
        {
            var tempFolder = Path.GetTempPath();
            var tempFileName = $"{Path.GetFileNameWithoutExtension(_sourcePath)}_temp_{Guid.NewGuid()}.mp4";
            renderJob.IntermediatePath = Path.Combine(tempFolder, tempFileName);
        }

        if (_renderType == RenderType.MltProject || isTwoStage)
        {
            // Set up MLT render settings (for direct MLT renders OR first stage of two-stage)
            renderJob.MeltSettings = new MeltRenderSettings
            {
                ThreadCount = _mltThreads,
                Preset = _mltPreset,
                Crf = _mltCrf,
                VideoCodec = _appSettings?.DefaultCodec ?? "libx264",
                AudioCodec = "aac",
                AudioBitrate = "128k",
                UseHardwareAcceleration = false // Always false for MLT
            };

            // Store frame rate for timecode conversion
            if (_loadedMltProject != null)
            {
                renderJob.FrameRate = _loadedMltProject.GetFrameRate();
            }

            // Set track selection
            var selectedVideoIndices = _videoTracks
                .Where(t => t.Selected)
                .Select(t => t.Info.Index.ToString())
                .ToArray();

            var selectedAudioIndices = _audioTracks
                .Where(t => t.Selected)
                .Select(t => t.Info.Index.ToString())
                .ToArray();

            renderJob.SelectedVideoTracks = selectedVideoIndices.Length > 0
                ? string.Join(",", selectedVideoIndices)
                : null;

            renderJob.SelectedAudioTracks = selectedAudioIndices.Length > 0
                ? string.Join(",", selectedAudioIndices)
                : null;

            // Set in/out points for partial rendering
            if (_useCustomRange)
            {
                // Use custom range if specified
                renderJob.InPoint = _customInPoint;
                renderJob.OutPoint = _customOutPoint;
            }
            else if (_loadedMltProject != null)
            {
                // Use markers from project file
                renderJob.InPoint = _loadedMltProject.InMarker;
                renderJob.OutPoint = _loadedMltProject.OutMarker;
            }

            // For direct MLT renders, serialize MeltSettings
            if (_renderType == RenderType.MltProject)
            {
                renderJob.RenderSettings = System.Text.Json.JsonSerializer.Serialize(renderJob.MeltSettings);
            }
        }

        if (_renderType == RenderType.RifeInterpolation)
        {
            // Set up RIFE settings (for direct RIFE OR second stage of two-stage)
            var ffmpegSettings = _rifeQuality switch
            {
                "draft" => await HardwareService.GetFastFFmpegSettingsAsync(_rifeTargetFps),
                "high" => await HardwareService.GetHighQualityFFmpegSettingsAsync(_rifeTargetFps),
                _ => await HardwareService.GetOptimalFFmpegSettingsAsync(_rifeTargetFps)
            };

            renderJob.FFmpegSettings = ffmpegSettings;
            renderJob.RifeSettings = new RifeSettings
            {
                InterpolationMultiplier = _rifeMultiplier,
                TargetFps = _rifeTargetFps,
                QualityPreset = _rifeQuality
            };

            // For RIFE renders, serialize both MeltSettings (if two-stage) and FFmpegSettings
            if (isTwoStage)
            {
                // Store both settings as JSON object for two-stage rendering
                var combinedSettings = new
                {
                    MeltSettings = renderJob.MeltSettings,
                    FFmpegSettings = renderJob.FFmpegSettings,
                    RifeSettings = renderJob.RifeSettings
                };
                renderJob.RenderSettings = System.Text.Json.JsonSerializer.Serialize(combinedSettings);
            }
            else
            {
                // Just FFmpeg settings for regular RIFE
                renderJob.RenderSettings = System.Text.Json.JsonSerializer.Serialize(renderJob.FFmpegSettings);
            }
        }

        await OnJobAdded.InvokeAsync(renderJob);
        await CloseDialog();
    }

    private async Task Cancel()
    {
        await CloseDialog();
    }

    private async Task CloseDialog()
    {
        await IsVisibleChanged.InvokeAsync(false);
    }

    private async Task OnDialogVisibleChanged(bool visible)
    {
        if (!visible)
        {
            await IsVisibleChanged.InvokeAsync(false);
        }
    }

    private void OnRenderTypeChanged(RenderType newRenderType)
    {
        _renderType = newRenderType;

        // Update output path suffix based on render type
        if (!string.IsNullOrEmpty(_sourcePath))
        {
            var videosFolder = Environment.GetFolderPath(Environment.SpecialFolder.MyVideos);
            var fileNameWithoutExt = Path.GetFileNameWithoutExtension(_sourcePath);
            var suffix = _renderType == RenderType.RifeInterpolation ? "_rife" : "_rendered";
            _outputPath = Path.Combine(videosFolder, $"{fileNameWithoutExt}{suffix}.mp4");
        }

        // Recalculate estimated time for new render type
        UpdateEstimatedTime();
    }
}
