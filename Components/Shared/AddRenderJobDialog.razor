@using CheapShotcutRandomizer.Models
@using CheapShotcutRandomizer.Services
@using CheapAvaloniaBlazor.Services
@using CheapHelpers.MediaProcessing.Services
@inject IDesktopInteropService DesktopInterop
@inject HardwareDetectionService HardwareService
@inject ShotcutService ShotcutService
@inject SettingsService SettingsService

<MudDialog Visible="@IsVisible"
           VisibleChanged="@OnDialogVisibleChanged"
           Options="@_dialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h5">Add Render Job</MudText>
    </TitleContent>
    <DialogContent>
        <MudStack Spacing="3">

            <MudStack Row="true" Spacing="2">
                <MudTextField @bind-Value="_sourcePath"
                              Label="Source File"
                              Variant="Variant.Outlined"
                              FullWidth="true"
                              ReadOnly="true" />
                <MudButton Variant="Variant.Filled"
                           Color="Color.Primary"
                           OnClick="@BrowseSource">
                    Browse...
                </MudButton>
            </MudStack>

            <MudStack Row="true" Spacing="2">
                <MudTextField @bind-Value="_outputPath"
                              Label="Output Path"
                              Variant="Variant.Outlined"
                              FullWidth="true"
                              ReadOnly="true" />
                <MudButton Variant="Variant.Filled"
                           Color="Color.Primary"
                           OnClick="@BrowseOutput">
                    Browse...
                </MudButton>
            </MudStack>

            @* Source type auto-detected from file extension *@
            @if (!string.IsNullOrEmpty(_sourcePath))
            {
                <MudAlert Severity="Severity.Info" Dense="true">
                    Source Type: @(_isMltSource ? "MLT Project" : "Video File")
                </MudAlert>
            }

            @* Note: AI/upscaling options (RIFE, Real-CUGAN, Real-ESRGAN, Non-AI upscaling) have been moved to CheapUpscaler *@
            @* Render the output here, then use CheapUpscaler to apply AI upscaling/interpolation *@

            @* MLT Encoding Settings - Show ONLY for MLT source files *@
            @if (_isMltSource)
            {
                <MudDivider />
                <MudText Typo="Typo.subtitle2">MLT Render Settings</MudText>

                <MudSlider @bind-Value="_mltThreads"
                           Min="1"
                           Max="@_maxThreads"
                           Step="1"
                           Color="Color.Primary"
                           Style="width: 100%;">
                    CPU Threads: @_mltThreads
                </MudSlider>

                <MudSelect @bind-Value="_mltPreset"
                           Label="Quality Preset"
                           Variant="Variant.Outlined"
                           T="string">
                    <MudSelectItem Value="@("ultrafast")" T="string">Ultra Fast</MudSelectItem>
                    <MudSelectItem Value="@("superfast")" T="string">Super Fast</MudSelectItem>
                    <MudSelectItem Value="@("veryfast")" T="string">Very Fast</MudSelectItem>
                    <MudSelectItem Value="@("faster")" T="string">Faster</MudSelectItem>
                    <MudSelectItem Value="@("fast")" T="string">Fast</MudSelectItem>
                    <MudSelectItem Value="@("medium")" T="string">Medium (Recommended)</MudSelectItem>
                    <MudSelectItem Value="@("slow")" T="string">Slow</MudSelectItem>
                    <MudSelectItem Value="@("slower")" T="string">Slower</MudSelectItem>
                </MudSelect>

                <MudSlider @bind-Value="_mltCrf"
                           Min="15"
                           Max="28"
                           Step="1"
                           Color="Color.Primary"
                           Style="width: 100%;">
                    Quality (CRF): @_mltCrf (Lower = Better)
                </MudSlider>
            }

            @* Track Selection - Show for MLT source files only, when ShowTrackSelection is true *@
            @if (ShowTrackSelection && _isMltSource && _tracks.Any())
            {
                <MudDivider />
                <MudText Typo="Typo.subtitle2">Track Selection</MudText>

                @if (_videoTracks.Any())
                {
                    <MudText Typo="Typo.body2" Color="Color.Primary">Video Tracks</MudText>
                    <MudStack Row="true" Spacing="2">
                        @foreach (var track in _videoTracks)
                        {
                            <MudCheckBox @bind-Value="track.Selected"
                                         Label="@track.DisplayName"
                                         Color="Color.Primary"
                                         T="bool" />
                        }
                    </MudStack>
                }

                @if (_audioTracks.Any())
                {
                    <MudText Typo="Typo.body2" Color="Color.Secondary">Audio Tracks</MudText>
                    <MudStack Row="true" Spacing="2">
                        @foreach (var track in _audioTracks)
                        {
                            <MudCheckBox @bind-Value="track.Selected"
                                         Label="@track.DisplayName"
                                         Color="Color.Secondary"
                                         T="bool" />
                        }
                    </MudStack>
                }
            }

            @* Render Range - Show for MLT sources only, when ShowRenderRange is true *@
            @if (ShowRenderRange && _isMltSource && !string.IsNullOrEmpty(_renderRangeDescription))
            {
                <MudDivider />
                <MudText Typo="Typo.subtitle2">Render Range</MudText>

                @if (!_useCustomRange)
                {
                    <MudAlert Severity="Severity.Info" Icon="@Icons.Material.Filled.ContentCut">
                        @_renderRangeDescription
                    </MudAlert>
                }

                <MudCheckBox @bind-Value="_useCustomRange" T="bool" Label="Override Markers (Custom Range)" Color="Color.Primary" />

                @if (_useCustomRange)
                {
                    @if (!string.IsNullOrEmpty(_maxEndTimeDisplay))
                    {
                        <MudAlert Severity="Severity.Normal" Dense="true">
                            Maximum end time: @_maxEndTimeDisplay
                        </MudAlert>
                    }

                    <MudStack Row="true" Spacing="2">
                        <MudTextField @bind-Value="_inPointTimecode"
                                      Label="Start Time (HH:MM:SS.mmm)"
                                      Variant="Variant.Outlined"
                                      Placeholder="00:00:00.000"
                                      HelperText="Format: HH:MM:SS or HH:MM:SS.mmm"
                                      Error="@_inPointError"
                                      ErrorText="@_inPointErrorText" />
                        <MudTextField @bind-Value="_outPointTimecode"
                                      Label="End Time (HH:MM:SS.mmm)"
                                      Variant="Variant.Outlined"
                                      Placeholder="00:10:30.000"
                                      HelperText="Format: HH:MM:SS or HH:MM:SS.mmm"
                                      Error="@_outPointError"
                                      ErrorText="@_outPointErrorText" />
                    </MudStack>
                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                        Leave empty to render from start or to end
                    </MudText>
                }
            }

            @if (!string.IsNullOrEmpty(_estimatedTime))
            {
                <MudAlert Severity="Severity.Info">
                    @_estimatedTime
                </MudAlert>
            }

            @if (!string.IsNullOrEmpty(_validationError))
            {
                <MudAlert Severity="Severity.Error">
                    @_validationError
                </MudAlert>
            }
        </MudStack>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="@Cancel" Variant="Variant.Text">Cancel</MudButton>
        <MudButton Color="Color.Primary"
                   Variant="Variant.Filled"
                   OnClick="@AddJob"
                   Disabled="@(!IsValid())">
            Add to Queue
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [Parameter]
    public bool IsVisible { get; set; }

    [Parameter]
    public EventCallback<bool> IsVisibleChanged { get; set; }

    [Parameter]
    public EventCallback<RenderJob> OnJobAdded { get; set; }

    [Parameter]
    public string? PrePopulatedSourcePath { get; set; }

    [Parameter]
    public bool ShowTrackSelection { get; set; } = true;

    [Parameter]
    public bool ShowRenderRange { get; set; } = true;

    [Parameter]
    public string? PreSelectedVideoTracks { get; set; }

    [Parameter]
    public string? PreSelectedAudioTracks { get; set; }

    private string _sourcePath = string.Empty;
    private string _outputPath = string.Empty;
    private bool _isMltSource = false; // Auto-detected from file extension

    // MLT settings
    private int _mltThreads = Environment.ProcessorCount;
    private int _maxThreads = Environment.ProcessorCount;
    private string _mltPreset = "medium";
    private int _mltCrf = 23;

    // Note: AI upscaling/interpolation (RIFE, Real-CUGAN, Real-ESRGAN) moved to CheapUpscaler

    private string _estimatedTime = string.Empty;
    private string _validationError = string.Empty;
    private HardwareCapabilities? _hardware;
    private AppSettings? _appSettings;

    // Track selection
    private List<SelectableTrack> _tracks = [];
    private List<SelectableTrack> _videoTracks = [];
    private List<SelectableTrack> _audioTracks = [];

    // Marker/range settings
    private Mlt? _loadedMltProject;
    private string _renderRangeDescription = string.Empty;
    private bool _useCustomRange = false;
    private int? _customInPoint;
    private int? _customOutPoint;
    private string _inPointTimecode = string.Empty;
    private string _outPointTimecode = string.Empty;
    private bool _inPointError = false;
    private string _inPointErrorText = string.Empty;
    private bool _outPointError = false;
    private string _outPointErrorText = string.Empty;
    private string _maxEndTimeDisplay = string.Empty;

    private DialogOptions _dialogOptions = new()
    {
        MaxWidth = MaxWidth.Medium,
        FullWidth = true,
        CloseButton = true,
        BackdropClick = false,
        Position = DialogPosition.Center
    };

    private class SelectableTrack
    {
        public TrackInfo Info { get; set; } = null!;
        public bool Selected { get; set; } = true;
        public string DisplayName => $"{Info.Name} ({Info.Type.ToUpper()[0]}{Info.Index})";
    }

    protected override async Task OnInitializedAsync()
    {
        _hardware = await HardwareService.DetectHardwareAsync();
        _maxThreads = _hardware.CpuCoreCount;
        _mltThreads = _hardware.CpuCoreCount;

        // Load app settings for defaults
        _appSettings = await SettingsService.LoadSettingsAsync();
        _mltCrf = _appSettings.DefaultCrf;
        _mltPreset = _appSettings.DefaultPreset;

        // Set default output folder to user's Videos directory
        var videosFolder = Environment.GetFolderPath(Environment.SpecialFolder.MyVideos);
        _outputPath = Path.Combine(videosFolder, "output.mp4");
    }

    protected override async Task OnParametersSetAsync()
    {
        // If a source path is pre-populated and different from current, load it automatically
        if (!string.IsNullOrEmpty(PrePopulatedSourcePath) && _sourcePath != PrePopulatedSourcePath)
        {
            _sourcePath = PrePopulatedSourcePath;

            // Auto-detect source type from file extension
            _isMltSource = _sourcePath.EndsWith(".mlt", StringComparison.OrdinalIgnoreCase);

            // Auto-populate output path
            UpdateOutputPath();

            // Load tracks and markers if this is an MLT file
            if (File.Exists(_sourcePath) && _isMltSource)
            {
                await LoadMltProjectDataAsync(_sourcePath);
            }

            UpdateEstimatedTime();
        }

        await base.OnParametersSetAsync();
    }

    private async Task BrowseSource()
    {
        // CheapShotcutRandomizer only renders MLT project files
        // For video upscaling/interpolation, use CheapUpscaler
        var filters = new List<CheapAvaloniaBlazor.Models.FileFilter>
        {
            new() { Name = "MLT Project Files", Extensions = new[] { "*.mlt" } },
            new() { Name = "All Files", Extensions = new[] { "*.*" } }
        };

        var options = new CheapAvaloniaBlazor.Models.FileDialogOptions
        {
            Title = "Select Source File",
            Filters = filters
        };

        var selectedFile = await DesktopInterop.OpenFileDialogAsync(options);

        if (!string.IsNullOrEmpty(selectedFile))
        {
            _sourcePath = selectedFile;

            // Auto-detect source type from file extension
            _isMltSource = _sourcePath.EndsWith(".mlt", StringComparison.OrdinalIgnoreCase);

            // Auto-populate output path to Videos folder with source filename
            UpdateOutputPath();

            // Load tracks and markers if this is an MLT file
            if (_isMltSource)
            {
                await LoadMltProjectDataAsync(_sourcePath);
            }

            UpdateEstimatedTime();
        }
    }

    private async Task BrowseOutput()
    {
        var defaultFileName = !string.IsNullOrEmpty(_sourcePath)
            ? Path.GetFileNameWithoutExtension(_sourcePath) + ".mp4"
            : "output.mp4";

        var filters = new List<CheapAvaloniaBlazor.Models.FileFilter>
        {
            new() { Name = "MP4 Files", Extensions = new[] { "*.mp4" } },
            new() { Name = "MKV Files", Extensions = new[] { "*.mkv" } },
            new() { Name = "All Files", Extensions = new[] { "*.*" } }
        };

        var options = new CheapAvaloniaBlazor.Models.FileDialogOptions
        {
            Title = "Save Output As",
            DefaultFileName = defaultFileName,
            Filters = filters
        };

        var selectedFile = await DesktopInterop.SaveFileDialogAsync(options);

        if (!string.IsNullOrEmpty(selectedFile))
        {
            _outputPath = selectedFile;
        }
    }

    private async Task LoadMltProjectDataAsync(string mltPath)
    {
        try
        {
            var project = await ShotcutService.LoadProjectAsync(mltPath);
            if (project != null)
            {
                _loadedMltProject = project;

                // Load tracks
                var trackInfos = ShotcutService.GetTracks(project);

                // Parse pre-selected tracks if provided
                HashSet<int>? preSelectedVideoIndices = null;
                if (!string.IsNullOrEmpty(PreSelectedVideoTracks))
                {
                    preSelectedVideoIndices = PreSelectedVideoTracks
                        .Split(',', StringSplitOptions.RemoveEmptyEntries)
                        .Select(int.Parse)
                        .ToHashSet();
                }

                HashSet<int>? preSelectedAudioIndices = null;
                if (!string.IsNullOrEmpty(PreSelectedAudioTracks))
                {
                    preSelectedAudioIndices = PreSelectedAudioTracks
                        .Split(',', StringSplitOptions.RemoveEmptyEntries)
                        .Select(int.Parse)
                        .ToHashSet();
                }

                _tracks = trackInfos.Select(t => new SelectableTrack
                {
                    Info = t,
                    // If pre-selection is provided, use that; otherwise select if not hidden
                    Selected = t.Type == "video"
                        ? (preSelectedVideoIndices?.Contains(t.Index) ?? !t.IsHidden)
                        : (preSelectedAudioIndices?.Contains(t.Index) ?? !t.IsHidden)
                }).ToList();

                _videoTracks = _tracks.Where(t => t.Info.Type == "video").ToList();
                _audioTracks = _tracks.Where(t => t.Info.Type == "audio").ToList();

                // Load markers
                _loadedMltProject.ParseMarkers();
                _renderRangeDescription = _loadedMltProject.GetRenderRangeDescription();

                // Calculate and display max end time
                var maxEndTime = _loadedMltProject.GetTotalDurationTimecode();
                if (!string.IsNullOrEmpty(maxEndTime))
                    _maxEndTimeDisplay = maxEndTime;

                // Initialize custom range with project markers
                _customInPoint = _loadedMltProject.InMarker;
                _customOutPoint = _loadedMltProject.OutMarker;

                // Initialize timecode fields
                if (_loadedMltProject.InMarker.HasValue)
                    _inPointTimecode = _loadedMltProject.FramesToTimecode(_loadedMltProject.InMarker.Value);

                if (_loadedMltProject.OutMarker.HasValue)
                    _outPointTimecode = _loadedMltProject.FramesToTimecode(_loadedMltProject.OutMarker.Value);
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Error loading MLT project data: {ex.Message}");
            _tracks = [];
            _videoTracks = [];
            _audioTracks = [];
            _renderRangeDescription = string.Empty;
            _maxEndTimeDisplay = string.Empty;
        }
    }

    private void UpdateEstimatedTime()
    {
        if (_hardware == null || string.IsNullOrEmpty(_sourcePath) || !_isMltSource)
        {
            _estimatedTime = string.Empty;
            return;
        }

        // Estimate based on typical video duration (placeholder - would need actual video info)
        var estimatedDuration = TimeSpan.FromMinutes(10); // Default estimate

        // MLT render - can use NVENC or CPU based on codec setting
        var useNvenc = _appSettings?.DefaultCodec?.Contains("nvenc") ?? false;
        var renderTime = _hardware.EstimateFFmpegRenderTime(estimatedDuration, useNvenc);
        var method = useNvenc ? "NVENC" : "CPU";
        _estimatedTime = $"Estimated render time: ~{renderTime.TotalMinutes:F0} minutes ({method})";

        if (useNvenc && _hardware.NvencAvailable)
        {
            var cpuTime = _hardware.EstimateFFmpegRenderTime(estimatedDuration, useNvenc: false);
            _estimatedTime += $" - Saves ~{(cpuTime - renderTime).TotalMinutes:F0} minutes vs CPU!";
        }
    }

    private void ValidateAndConvertTimecodes()
    {
        // Reset errors
        _inPointError = false;
        _inPointErrorText = string.Empty;
        _outPointError = false;
        _outPointErrorText = string.Empty;

        if (_loadedMltProject == null || !_useCustomRange)
            return;

        // Validate and convert in point
        if (!string.IsNullOrWhiteSpace(_inPointTimecode))
        {
            try
            {
                _customInPoint = _loadedMltProject.TimecodeToFrames(_inPointTimecode);
            }
            catch (Exception ex)
            {
                _inPointError = true;
                _inPointErrorText = $"Invalid timecode format: {ex.Message}";
                _customInPoint = null;
            }
        }
        else
        {
            _customInPoint = null;
        }

        // Validate and convert out point
        if (!string.IsNullOrWhiteSpace(_outPointTimecode))
        {
            try
            {
                _customOutPoint = _loadedMltProject.TimecodeToFrames(_outPointTimecode);
            }
            catch (Exception ex)
            {
                _outPointError = true;
                _outPointErrorText = $"Invalid timecode format: {ex.Message}";
                _customOutPoint = null;
            }
        }
        else
        {
            _customOutPoint = null;
        }
    }

    private bool IsValid()
    {
        _validationError = string.Empty;

        if (string.IsNullOrEmpty(_sourcePath))
        {
            _validationError = "Please select a source file";
            return false;
        }

        // Don't check File.Exists here - it will be checked when actually adding the job
        // This prevents validation errors while the file is being written

        if (string.IsNullOrEmpty(_outputPath))
        {
            _validationError = "Please specify an output path";
            return false;
        }

        // CheapShotcutRandomizer only supports MLT source files
        // For video upscaling/interpolation, use CheapUpscaler
        if (!_sourcePath.EndsWith(".mlt", StringComparison.OrdinalIgnoreCase))
        {
            _validationError = "Source file must be an MLT project (.mlt). For video upscaling/interpolation, use CheapUpscaler.";
            return false;
        }

        // Validate timecodes if custom range is enabled (only for MLT files)
        var isSourceMlt = _sourcePath.EndsWith(".mlt", StringComparison.OrdinalIgnoreCase);
        if (_useCustomRange && isSourceMlt)
        {
            ValidateAndConvertTimecodes();

            if (_inPointError || _outPointError)
            {
                _validationError = "Please fix timecode format errors";
                return false;
            }
        }

        return true;
    }

    private async Task AddJob()
    {
        if (!IsValid())
            return;

        // Verify source file actually exists before proceeding
        if (!File.Exists(_sourcePath))
        {
            _validationError = "Source file does not exist";
            StateHasChanged();
            return;
        }

        // CheapShotcutRandomizer only renders MLT sources (single-stage melt render)
        // For AI upscaling/interpolation, use CheapUpscaler after rendering
        var renderJob = new RenderJob
        {
            SourceVideoPath = _sourcePath,
            OutputPath = _outputPath,
            RenderType = RenderType.MltSource,
            Status = RenderJobStatus.Pending
        };

        {
            // Set up MLT render settings (first stage for MLT sources)
            renderJob.MeltSettings = new MeltRenderSettings
            {
                ThreadCount = _mltThreads,
                Preset = _mltPreset,
                Crf = _mltCrf,
                VideoCodec = _appSettings?.DefaultCodec ?? "libx264",
                AudioCodec = "aac",
                AudioBitrate = "128k",
                UseHardwareAcceleration = false // Always false for MLT
            };

            // Store frame rate for timecode conversion
            if (_loadedMltProject != null)
            {
                renderJob.FrameRate = _loadedMltProject.GetFrameRate();
            }

            // Set track selection
            // IMPORTANT: Use actual tractor indices (Info.Index), not re-indexed positions
            // The track Index from GetTracks() is the ACTUAL position in the tractor
            // MeltRenderService.ApplyTrackSelectionAsync expects these tractor indices
            var selectedVideoIndices = _videoTracks
                .Where(t => t.Selected)
                .Select(t => t.Info.Index.ToString())
                .ToArray();

            var selectedAudioIndices = _audioTracks
                .Where(t => t.Selected)
                .Select(t => t.Info.Index.ToString())
                .ToArray();

            renderJob.SelectedVideoTracks = selectedVideoIndices.Length > 0
                ? string.Join(",", selectedVideoIndices)
                : null;

            renderJob.SelectedAudioTracks = selectedAudioIndices.Length > 0
                ? string.Join(",", selectedAudioIndices)
                : null;

            // Set in/out points for partial rendering
            if (_useCustomRange)
            {
                // Use custom range if specified
                renderJob.InPoint = _customInPoint;
                renderJob.OutPoint = _customOutPoint;
            }
            else if (_loadedMltProject != null)
            {
                // Use markers from project file
                renderJob.InPoint = _loadedMltProject.InMarker;
                renderJob.OutPoint = _loadedMltProject.OutMarker;
            }

        }

        // Serialize MLT render settings
        renderJob.RenderSettings = System.Text.Json.JsonSerializer.Serialize(renderJob.MeltSettings);

        await OnJobAdded.InvokeAsync(renderJob);
        await CloseDialog();
    }

    private async Task Cancel()
    {
        await CloseDialog();
    }

    private async Task CloseDialog()
    {
        await IsVisibleChanged.InvokeAsync(false);
    }

    private async Task OnDialogVisibleChanged(bool visible)
    {
        if (!visible)
        {
            await IsVisibleChanged.InvokeAsync(false);
        }
    }

    private void UpdateOutputPath()
    {
        if (!string.IsNullOrEmpty(_sourcePath))
        {
            var videosFolder = Environment.GetFolderPath(Environment.SpecialFolder.MyVideos);
            var fileNameWithoutExt = Path.GetFileNameWithoutExtension(_sourcePath);

            // MLT-only rendering - always use _rendered suffix
            _outputPath = Path.Combine(videosFolder, $"{fileNameWithoutExt}_rendered.mp4");
        }
    }
}
